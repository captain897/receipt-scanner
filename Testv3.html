<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Receipt Scanner v3</title>
    
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            min-height: 100vh;
            color: white;
        }
        
        .container {
            max-width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* Camera View */
        #cameraSection {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        #cameraSection.hidden {
            display: none;
        }
        
        .video-wrapper {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        /* Status Bar */
        .status-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
            padding: 15px;
            padding-top: 25px;
            z-index: 10;
        }
        
        .status-text {
            font-size: 14px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #888;
            transition: background 0.3s;
        }
        
        .status-dot.searching {
            background: #ffa500;
            animation: pulse 1s infinite;
        }
        
        .status-dot.detected {
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }
        
        .status-dot.capturing {
            background: #00ffff;
            animation: flash 0.3s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        @keyframes flash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        /* Controls */
        .controls {
            background: #1a1a2e;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }
        
        .btn {
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .btn-capture {
            width: 70px;
            height: 70px;
            background: white;
            box-shadow: 0 0 0 4px rgba(255,255,255,0.3);
        }
        
        .btn-capture:active {
            transform: scale(0.95);
        }
        
        .btn-capture-inner {
            width: 58px;
            height: 58px;
            background: white;
            border-radius: 50%;
            border: 3px solid #1a1a2e;
        }
        
        .btn-capture.detected .btn-capture-inner {
            background: #00ff00;
            border-color: #00aa00;
        }
        
        .btn-small {
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.2);
            font-size: 20px;
        }
        
        /* Preview Section */
        #previewSection {
            display: none;
            flex-direction: column;
            height: 100vh;
        }
        
        #previewSection.active {
            display: flex;
        }
        
        .preview-header {
            background: #1a1a2e;
            padding: 15px;
            text-align: center;
            font-weight: 600;
        }
        
        .preview-image-container {
            flex: 1;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }
        
        #previewCanvas {
            max-width: 100%;
            max-height: 100%;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,255,100,0.3);
        }
        
        .preview-controls {
            background: #1a1a2e;
            padding: 20px;
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        
        .btn-action {
            padding: 14px 28px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            cursor: pointer;
        }
        
        .btn-retake {
            background: rgba(255,255,255,0.2);
            color: white;
        }
        
        .btn-use {
            background: #00cc66;
            color: white;
        }
        
        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .loading-overlay.hidden {
            display: none;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255,255,255,0.2);
            border-top-color: #00cc66;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            margin-top: 20px;
            font-size: 16px;
        }
        
        .loading-subtext {
            margin-top: 8px;
            font-size: 12px;
            opacity: 0.6;
        }
        
        /* Hint text */
        .hint {
            position: absolute;
            bottom: 10px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 12px;
            opacity: 0.7;
            padding: 0 20px;
        }
        
        /* Capture flash effect */
        .capture-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 999;
            transition: opacity 0.1s;
        }
        
        .capture-flash.active {
            opacity: 0.8;
        }
        
        /* Hidden elements */
        .hidden-canvas {
            display: none;
        }
        
        /* Progress bar for auto-capture */
        .capture-progress {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .capture-progress-bar {
            height: 100%;
            background: #00ff00;
            width: 0%;
            transition: width 0.15s;
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <div class="loading-text">Loading Scanner</div>
        <div class="loading-subtext">Initializing camera...</div>
    </div>
    
    <div class="capture-flash" id="captureFlash"></div>

    <div class="container">
        <!-- Camera Section -->
        <div id="cameraSection">
            <div class="video-wrapper">
                <video id="video" autoplay playsinline muted></video>
                <canvas id="overlayCanvas"></canvas>
                
                <div class="status-bar">
                    <div class="status-text">
                        <div class="status-dot" id="statusDot"></div>
                        <span id="statusText">Initializing...</span>
                    </div>
                </div>
                
                <div class="capture-progress" id="captureProgress" style="display:none;">
                    <div class="capture-progress-bar" id="captureProgressBar"></div>
                </div>
                
                <div class="hint" id="hintText">Point camera at receipt</div>
            </div>
            
            <div class="controls">
                <button class="btn btn-small" id="switchCameraBtn">üîÑ</button>
                <button class="btn btn-capture" id="captureBtn">
                    <div class="btn-capture-inner"></div>
                </button>
                <button class="btn btn-small" id="autoToggleBtn" title="Auto-capture ON">üÖ∞Ô∏è</button>
            </div>
        </div>
        
        <!-- Preview Section -->
        <div id="previewSection">
            <div class="preview-header">
                ‚úì Receipt Captured
            </div>
            <div class="preview-image-container">
                <canvas id="previewCanvas"></canvas>
            </div>
            <div class="preview-controls">
                <button class="btn-action btn-retake" id="retakeBtn">Retake</button>
                <button class="btn-action btn-use" id="useImageBtn">Use Photo</button>
            </div>
        </div>
    </div>
    
    <canvas id="captureCanvas" class="hidden-canvas"></canvas>
    
    <!-- OpenCV.js -->
    <script>
        var Module = {
            onRuntimeInitialized: function() {
                console.log('OpenCV ready');
                window.opencvReady = true;
                initScanner();
            }
        };
    </script>
    <script async src="https://docs.opencv.org/4.7.0/opencv.js"></script>
    
    <script>
        // State
        let video, stream;
        let overlayCanvas, overlayCtx;
        let captureCanvas, captureCtx;
        let previewCanvas, previewCtx;
        let detectionLoop = null;
        let detectedCorners = null;
        let currentFacingMode = 'environment';
        let capturedImageData = null;
        let consecutiveDetections = 0;
        let autoCapture = true;
        
        const AUTO_CAPTURE_THRESHOLD = 8; // Need 8 consecutive good detections (~1.2 seconds)
        
        // DOM
        const loadingOverlay = document.getElementById('loadingOverlay');
        const cameraSection = document.getElementById('cameraSection');
        const previewSection = document.getElementById('previewSection');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const captureBtn = document.getElementById('captureBtn');
        const captureProgress = document.getElementById('captureProgress');
        const captureProgressBar = document.getElementById('captureProgressBar');
        const hintText = document.getElementById('hintText');
        const captureFlash = document.getElementById('captureFlash');
        const autoToggleBtn = document.getElementById('autoToggleBtn');
        
        // Initialize
        function initScanner() {
            if (!window.opencvReady) {
                setTimeout(initScanner, 100);
                return;
            }
            
            video = document.getElementById('video');
            overlayCanvas = document.getElementById('overlayCanvas');
            overlayCtx = overlayCanvas.getContext('2d');
            captureCanvas = document.getElementById('captureCanvas');
            captureCtx = captureCanvas.getContext('2d');
            previewCanvas = document.getElementById('previewCanvas');
            previewCtx = previewCanvas.getContext('2d');
            
            startCamera();
        }
        
        // Start camera
        async function startCamera() {
            try {
                if (stream) {
                    stream.getTracks().forEach(t => t.stop());
                }
                
                stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: currentFacingMode,
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                });
                
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    video.play();
                    overlayCanvas.width = video.videoWidth;
                    overlayCanvas.height = video.videoHeight;
                    captureCanvas.width = video.videoWidth;
                    captureCanvas.height = video.videoHeight;
                    
                    loadingOverlay.classList.add('hidden');
                    startDetection();
                };
            } catch (err) {
                console.error('Camera error:', err);
                loadingOverlay.querySelector('.loading-text').textContent = 'Camera Error';
                loadingOverlay.querySelector('.loading-subtext').textContent = 'Please allow camera access';
            }
        }
        
        // Detect document using multiple methods
        function detectDocument(canvas) {
            const src = cv.imread(canvas);
            let bestContour = null;
            let bestScore = 0;
            
            try {
                // Try multiple detection methods
                const methods = [
                    () => detectWithCanny(src, 30, 100),
                    () => detectWithCanny(src, 50, 150),
                    () => detectWithCanny(src, 75, 200),
                    () => detectWithAdaptiveThreshold(src),
                    () => detectWithOtsu(src)
                ];
                
                for (const method of methods) {
                    try {
                        const corners = method();
                        if (corners) {
                            const score = scoreContour(corners, canvas.width, canvas.height);
                            if (score > bestScore) {
                                bestScore = score;
                                bestContour = corners;
                            }
                        }
                    } catch (e) {
                        // Continue to next method
                    }
                }
            } finally {
                src.delete();
            }
            
            return bestContour;
        }
        
        // Canny edge detection
        function detectWithCanny(src, thresh1, thresh2) {
            const gray = new cv.Mat();
            const blur = new cv.Mat();
            const edges = new cv.Mat();
            const contours = new cv.MatVector();
            const hierarchy = new cv.Mat();
            
            try {
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 0);
                cv.Canny(blur, edges, thresh1, thresh2);
                
                const kernel = cv.Mat.ones(3, 3, cv.CV_8U);
                cv.dilate(edges, edges, kernel);
                kernel.delete();
                
                cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                return findLargestQuad(contours, src.cols, src.rows);
            } finally {
                gray.delete();
                blur.delete();
                edges.delete();
                contours.delete();
                hierarchy.delete();
            }
        }
        
        // Adaptive threshold
        function detectWithAdaptiveThreshold(src) {
            const gray = new cv.Mat();
            const blur = new cv.Mat();
            const thresh = new cv.Mat();
            const contours = new cv.MatVector();
            const hierarchy = new cv.Mat();
            
            try {
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 0);
                cv.adaptiveThreshold(blur, thresh, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);
                cv.findContours(thresh, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                return findLargestQuad(contours, src.cols, src.rows);
            } finally {
                gray.delete();
                blur.delete();
                thresh.delete();
                contours.delete();
                hierarchy.delete();
            }
        }
        
        // OTSU threshold
        function detectWithOtsu(src) {
            const gray = new cv.Mat();
            const blur = new cv.Mat();
            const thresh = new cv.Mat();
            const contours = new cv.MatVector();
            const hierarchy = new cv.Mat();
            
            try {
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 0);
                cv.threshold(blur, thresh, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);
                cv.findContours(thresh, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                return findLargestQuad(contours, src.cols, src.rows);
            } finally {
                gray.delete();
                blur.delete();
                thresh.delete();
                contours.delete();
                hierarchy.delete();
            }
        }
        
        // Find largest quadrilateral
        function findLargestQuad(contours, width, height) {
            let maxArea = 0;
            let bestCorners = null;
            const minArea = (width * height) * 0.05;
            const maxAreaLimit = (width * height) * 0.95;
            
            for (let i = 0; i < contours.size(); i++) {
                const contour = contours.get(i);
                const area = cv.contourArea(contour);
                
                if (area < minArea || area > maxAreaLimit) continue;
                
                const peri = cv.arcLength(contour, true);
                const approx = new cv.Mat();
                cv.approxPolyDP(contour, approx, 0.02 * peri, true);
                
                if (approx.rows === 4 && area > maxArea) {
                    if (isValidQuad(approx, width, height)) {
                        maxArea = area;
                        bestCorners = [];
                        for (let j = 0; j < 4; j++) {
                            bestCorners.push({
                                x: approx.data32S[j * 2],
                                y: approx.data32S[j * 2 + 1]
                            });
                        }
                    }
                }
                approx.delete();
            }
            
            return bestCorners ? orderCorners(bestCorners) : null;
        }
        
        // Validate quadrilateral
        function isValidQuad(approx, width, height) {
            const corners = [];
            for (let i = 0; i < 4; i++) {
                corners.push({
                    x: approx.data32S[i * 2],
                    y: approx.data32S[i * 2 + 1]
                });
            }
            
            // Check all corners are within frame with margin
            const margin = 5;
            for (const c of corners) {
                if (c.x < margin || c.x > width - margin || c.y < margin || c.y > height - margin) {
                    return false;
                }
            }
            
            // Check angles
            const ordered = orderCorners(corners);
            for (let i = 0; i < 4; i++) {
                const p1 = ordered[i];
                const p2 = ordered[(i + 1) % 4];
                const p3 = ordered[(i + 2) % 4];
                const angle = getAngle(p1, p2, p3);
                if (angle < 45 || angle > 135) return false;
            }
            
            return true;
        }
        
        function getAngle(p1, p2, p3) {
            const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
            const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };
            const dot = v1.x * v2.x + v1.y * v2.y;
            const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
            const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
            return Math.acos(dot / (mag1 * mag2)) * (180 / Math.PI);
        }
        
        // Order corners: TL, TR, BR, BL
        function orderCorners(corners) {
            const sorted = [...corners].sort((a, b) => a.y - b.y);
            const top = sorted.slice(0, 2).sort((a, b) => a.x - b.x);
            const bottom = sorted.slice(2, 4).sort((a, b) => a.x - b.x);
            return [top[0], top[1], bottom[1], bottom[0]];
        }
        
        // Score contour
        function scoreContour(corners, width, height) {
            if (!corners || corners.length !== 4) return 0;
            
            const area = polygonArea(corners);
            const frameArea = width * height;
            const areaRatio = area / frameArea;
            
            if (areaRatio < 0.05 || areaRatio > 0.95) return 0;
            
            return areaRatio * 100;
        }
        
        function polygonArea(corners) {
            let area = 0;
            for (let i = 0; i < corners.length; i++) {
                const j = (i + 1) % corners.length;
                area += corners[i].x * corners[j].y - corners[j].x * corners[i].y;
            }
            return Math.abs(area / 2);
        }
        
        // Main detection loop
        function startDetection() {
            statusDot.classList.add('searching');
            statusText.textContent = 'Looking for document...';
            hintText.textContent = 'Point camera at receipt';
            
            detectionLoop = setInterval(() => {
                if (!video || video.paused) return;
                
                captureCtx.drawImage(video, 0, 0);
                overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                
                const corners = detectDocument(captureCanvas);
                
                if (corners && corners.length === 4) {
                    detectedCorners = corners;
                    consecutiveDetections++;
                    
                    // Draw detection overlay
                    drawDetectionOverlay(corners);
                    
                    // Update UI
                    statusDot.classList.remove('searching');
                    statusDot.classList.add('detected');
                    captureBtn.classList.add('detected');
                    
                    if (autoCapture) {
                        // Show progress
                        captureProgress.style.display = 'block';
                        const progress = Math.min((consecutiveDetections / AUTO_CAPTURE_THRESHOLD) * 100, 100);
                        captureProgressBar.style.width = progress + '%';
                        
                        if (consecutiveDetections < AUTO_CAPTURE_THRESHOLD) {
                            statusText.textContent = 'Hold steady...';
                            hintText.textContent = 'Keep still for auto-capture';
                        } else {
                            // AUTO CAPTURE!
                            statusDot.classList.add('capturing');
                            statusText.textContent = 'Capturing!';
                            triggerCapture();
                            return;
                        }
                    } else {
                        statusText.textContent = 'Document detected - tap to capture';
                        hintText.textContent = 'Tap the button to capture';
                        captureProgress.style.display = 'none';
                    }
                } else {
                    // Reset detection
                    consecutiveDetections = 0;
                    detectedCorners = null;
                    
                    statusDot.classList.remove('detected', 'capturing');
                    statusDot.classList.add('searching');
                    statusText.textContent = 'Looking for document...';
                    hintText.textContent = 'Point camera at receipt';
                    captureBtn.classList.remove('detected');
                    captureProgress.style.display = 'none';
                    captureProgressBar.style.width = '0%';
                }
                
            }, 150);
        }
        
        // Draw detection overlay
        function drawDetectionOverlay(corners) {
            const scaleX = overlayCanvas.width / captureCanvas.width;
            const scaleY = overlayCanvas.height / captureCanvas.height;
            
            // Draw filled polygon
            overlayCtx.beginPath();
            overlayCtx.moveTo(corners[0].x * scaleX, corners[0].y * scaleY);
            for (let i = 1; i < 4; i++) {
                overlayCtx.lineTo(corners[i].x * scaleX, corners[i].y * scaleY);
            }
            overlayCtx.closePath();
            
            overlayCtx.fillStyle = 'rgba(0, 255, 100, 0.2)';
            overlayCtx.fill();
            
            overlayCtx.strokeStyle = '#00ff66';
            overlayCtx.lineWidth = 4;
            overlayCtx.stroke();
            
            // Draw corners
            overlayCtx.fillStyle = '#00ff66';
            corners.forEach(corner => {
                overlayCtx.beginPath();
                overlayCtx.arc(corner.x * scaleX, corner.y * scaleY, 10, 0, Math.PI * 2);
                overlayCtx.fill();
            });
        }
        
        function stopDetection() {
            if (detectionLoop) {
                clearInterval(detectionLoop);
                detectionLoop = null;
            }
        }
        
        // Trigger capture with flash effect
        function triggerCapture() {
            stopDetection();
            
            // Flash effect
            captureFlash.classList.add('active');
            setTimeout(() => captureFlash.classList.remove('active'), 150);
            
            // Capture the frame
            captureCtx.drawImage(video, 0, 0);
            
            // Process and crop
            processCapture();
        }
        
        // Process captured image - CROP TO DETECTED AREA
        function processCapture() {
            let outputCanvas;
            
            if (detectedCorners && detectedCorners.length === 4) {
                // Apply perspective correction and crop to detected area
                outputCanvas = applyPerspectiveCorrection(captureCanvas, detectedCorners);
            } else {
                // Fallback: use full frame
                outputCanvas = document.createElement('canvas');
                outputCanvas.width = captureCanvas.width;
                outputCanvas.height = captureCanvas.height;
                outputCanvas.getContext('2d').drawImage(captureCanvas, 0, 0);
            }
            
            // Resize for output (max 1200px)
            const maxSize = 1200;
            const scale = Math.min(maxSize / outputCanvas.width, maxSize / outputCanvas.height, 1);
            
            previewCanvas.width = Math.round(outputCanvas.width * scale);
            previewCanvas.height = Math.round(outputCanvas.height * scale);
            previewCtx.drawImage(outputCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
            
            // Enhance
            enhanceImage(previewCanvas);
            
            // Store result
            capturedImageData = previewCanvas.toDataURL('image/jpeg', 0.85);
            
            // Show preview
            cameraSection.classList.add('hidden');
            previewSection.classList.add('active');
        }
        
        // Perspective correction - crops to just the document
        function applyPerspectiveCorrection(canvas, corners) {
            const src = cv.imread(canvas);
            
            // Calculate output dimensions based on detected document
            const widthTop = distance(corners[0], corners[1]);
            const widthBottom = distance(corners[3], corners[2]);
            const width = Math.round(Math.max(widthTop, widthBottom));
            
            const heightLeft = distance(corners[0], corners[3]);
            const heightRight = distance(corners[1], corners[2]);
            const height = Math.round(Math.max(heightLeft, heightRight));
            
            // Source points (detected corners)
            const srcPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
                corners[0].x, corners[0].y,
                corners[1].x, corners[1].y,
                corners[2].x, corners[2].y,
                corners[3].x, corners[3].y
            ]);
            
            // Destination points (rectangle)
            const dstPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
                0, 0,
                width, 0,
                width, height,
                0, height
            ]);
            
            const M = cv.getPerspectiveTransform(srcPts, dstPts);
            const dst = new cv.Mat();
            cv.warpPerspective(src, dst, M, new cv.Size(width, height));
            
            // Create output canvas
            const outputCanvas = document.createElement('canvas');
            outputCanvas.width = width;
            outputCanvas.height = height;
            cv.imshow(outputCanvas, dst);
            
            // Cleanup
            src.delete();
            srcPts.delete();
            dstPts.delete();
            M.delete();
            dst.delete();
            
            return outputCanvas;
        }
        
        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }
        
        // Image enhancement
        function enhanceImage(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Slight contrast boost
            const factor = 1.15;
            const intercept = 128 * (1 - factor);
            
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, Math.max(0, data[i] * factor + intercept));
                data[i + 1] = Math.min(255, Math.max(0, data[i + 1] * factor + intercept));
                data[i + 2] = Math.min(255, Math.max(0, data[i + 2] * factor + intercept));
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        // Retake
        function retake() {
            capturedImageData = null;
            consecutiveDetections = 0;
            detectedCorners = null;
            previewSection.classList.remove('active');
            cameraSection.classList.remove('hidden');
            startDetection();
        }
        
        // Use image
        function useImage() {
            alert('Image captured!\n\nSize: ' + Math.round(capturedImageData.length / 1024) + ' KB\n\nIn JotForm this would be submitted with your form.');
            console.log('Image data ready for form submission');
        }
        
        // Switch camera
        function switchCamera() {
            currentFacingMode = currentFacingMode === 'environment' ? 'user' : 'environment';
            stopDetection();
            consecutiveDetections = 0;
            startCamera();
        }
        
        // Toggle auto-capture
        function toggleAutoCapture() {
            autoCapture = !autoCapture;
            autoToggleBtn.textContent = autoCapture ? 'üÖ∞Ô∏è' : 'üì∑';
            autoToggleBtn.title = autoCapture ? 'Auto-capture ON' : 'Auto-capture OFF (manual)';
            
            if (!autoCapture) {
                captureProgress.style.display = 'none';
            }
        }
        
        // Event listeners
        captureBtn.addEventListener('click', () => {
            if (detectedCorners) {
                triggerCapture();
            } else {
                // Manual capture without detection
                stopDetection();
                captureCtx.drawImage(video, 0, 0);
                processCapture();
            }
        });
        
        document.getElementById('retakeBtn').addEventListener('click', retake);
        document.getElementById('useImageBtn').addEventListener('click', useImage);
        document.getElementById('switchCameraBtn').addEventListener('click', switchCamera);
        autoToggleBtn.addEventListener('click', toggleAutoCapture);
        
        // Wait for OpenCV
        function checkOpenCV() {
            if (typeof cv !== 'undefined' && cv.Mat) {
                window.opencvReady = true;
                initScanner();
            } else {
                setTimeout(checkOpenCV, 100);
            }
        }
        
        checkOpenCV();
    </script>
</body>
</html>

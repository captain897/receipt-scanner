<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Receipt Scanner v2</title>
    
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            min-height: 100vh;
            color: white;
        }
        
        .container {
            max-width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* Camera View */
        #cameraSection {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        
        #cameraSection.hidden {
            display: none;
        }
        
        .video-wrapper {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        /* Status Bar */
        .status-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
            padding: 15px;
            padding-top: 25px;
            z-index: 10;
        }
        
        .status-text {
            font-size: 14px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #888;
            transition: background 0.3s;
        }
        
        .status-dot.searching {
            background: #ffa500;
            animation: pulse 1s infinite;
        }
        
        .status-dot.detected {
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Controls */
        .controls {
            background: #1a1a2e;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }
        
        .btn {
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .btn-capture {
            width: 70px;
            height: 70px;
            background: white;
            box-shadow: 0 0 0 4px rgba(255,255,255,0.3);
        }
        
        .btn-capture:active {
            transform: scale(0.95);
        }
        
        .btn-capture-inner {
            width: 58px;
            height: 58px;
            background: white;
            border-radius: 50%;
            border: 3px solid #1a1a2e;
        }
        
        .btn-capture.detected .btn-capture-inner {
            background: #00ff00;
            border-color: #00aa00;
        }
        
        .btn-small {
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.2);
            font-size: 20px;
        }
        
        /* Preview Section */
        #previewSection {
            display: none;
            flex-direction: column;
            height: 100vh;
        }
        
        #previewSection.active {
            display: flex;
        }
        
        .preview-header {
            background: #1a1a2e;
            padding: 15px;
            text-align: center;
            font-weight: 600;
        }
        
        .preview-image-container {
            flex: 1;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }
        
        #previewCanvas {
            max-width: 100%;
            max-height: 100%;
            border-radius: 8px;
        }
        
        .preview-controls {
            background: #1a1a2e;
            padding: 20px;
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        
        .btn-action {
            padding: 14px 28px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            cursor: pointer;
        }
        
        .btn-retake {
            background: rgba(255,255,255,0.2);
            color: white;
        }
        
        .btn-use {
            background: #00cc66;
            color: white;
        }
        
        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a2e;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .loading-overlay.hidden {
            display: none;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255,255,255,0.2);
            border-top-color: #00cc66;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            margin-top: 20px;
            font-size: 16px;
        }
        
        .loading-subtext {
            margin-top: 8px;
            font-size: 12px;
            opacity: 0.6;
        }
        
        /* Guide overlay */
        .guide-frame {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 85%;
            height: 60%;
            border: 2px dashed rgba(255,255,255,0.4);
            border-radius: 8px;
            pointer-events: none;
        }
        
        .guide-corner {
            position: absolute;
            width: 20px;
            height: 20px;
            border-color: rgba(255,255,255,0.8);
            border-style: solid;
        }
        
        .guide-corner.tl { top: -2px; left: -2px; border-width: 3px 0 0 3px; }
        .guide-corner.tr { top: -2px; right: -2px; border-width: 3px 3px 0 0; }
        .guide-corner.bl { bottom: -2px; left: -2px; border-width: 0 0 3px 3px; }
        .guide-corner.br { bottom: -2px; right: -2px; border-width: 0 3px 3px 0; }
        
        .guide-frame.detected {
            border-color: #00ff00;
        }
        
        .guide-frame.detected .guide-corner {
            border-color: #00ff00;
        }
        
        /* Hidden elements */
        .hidden-canvas {
            display: none;
        }
        
        /* Hint text */
        .hint {
            position: absolute;
            bottom: 10px;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 12px;
            opacity: 0.7;
            padding: 0 20px;
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <div class="loading-text">Loading Scanner</div>
        <div class="loading-subtext">Initializing camera...</div>
    </div>

    <div class="container">
        <!-- Camera Section -->
        <div id="cameraSection">
            <div class="video-wrapper">
                <video id="video" autoplay playsinline muted></video>
                <canvas id="overlayCanvas"></canvas>
                
                <div class="status-bar">
                    <div class="status-text">
                        <div class="status-dot" id="statusDot"></div>
                        <span id="statusText">Initializing...</span>
                    </div>
                </div>
                
                <div class="guide-frame" id="guideFrame">
                    <div class="guide-corner tl"></div>
                    <div class="guide-corner tr"></div>
                    <div class="guide-corner bl"></div>
                    <div class="guide-corner br"></div>
                </div>
                
                <div class="hint">Position receipt within the frame</div>
            </div>
            
            <div class="controls">
                <button class="btn btn-small" id="switchCameraBtn">ðŸ”„</button>
                <button class="btn btn-capture" id="captureBtn">
                    <div class="btn-capture-inner"></div>
                </button>
                <button class="btn btn-small" id="flashBtn">âš¡</button>
            </div>
        </div>
        
        <!-- Preview Section -->
        <div id="previewSection">
            <div class="preview-header">
                âœ“ Receipt Captured
            </div>
            <div class="preview-image-container">
                <canvas id="previewCanvas"></canvas>
            </div>
            <div class="preview-controls">
                <button class="btn-action btn-retake" id="retakeBtn">Retake</button>
                <button class="btn-action btn-use" id="useImageBtn">Use Photo</button>
            </div>
        </div>
    </div>
    
    <canvas id="captureCanvas" class="hidden-canvas"></canvas>
    <canvas id="processCanvas" class="hidden-canvas"></canvas>
    
    <!-- OpenCV.js -->
    <script>
        var Module = {
            onRuntimeInitialized: function() {
                console.log('OpenCV ready');
                window.opencvReady = true;
                initScanner();
            }
        };
    </script>
    <script async src="https://docs.opencv.org/4.7.0/opencv.js"></script>
    
    <script>
        // State
        let video, stream;
        let overlayCanvas, overlayCtx;
        let captureCanvas, captureCtx;
        let processCanvas, processCtx;
        let previewCanvas, previewCtx;
        let detectionLoop = null;
        let isDocumentDetected = false;
        let detectedCorners = null;
        let currentFacingMode = 'environment';
        let capturedImageData = null;
        let consecutiveDetections = 0;
        const DETECTION_THRESHOLD = 3; // Need 3 consecutive detections
        
        // DOM
        const loadingOverlay = document.getElementById('loadingOverlay');
        const cameraSection = document.getElementById('cameraSection');
        const previewSection = document.getElementById('previewSection');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const guideFrame = document.getElementById('guideFrame');
        const captureBtn = document.getElementById('captureBtn');
        
        // Initialize
        function initScanner() {
            if (!window.opencvReady) {
                setTimeout(initScanner, 100);
                return;
            }
            
            video = document.getElementById('video');
            overlayCanvas = document.getElementById('overlayCanvas');
            overlayCtx = overlayCanvas.getContext('2d');
            captureCanvas = document.getElementById('captureCanvas');
            captureCtx = captureCanvas.getContext('2d');
            processCanvas = document.getElementById('processCanvas');
            processCtx = processCanvas.getContext('2d');
            previewCanvas = document.getElementById('previewCanvas');
            previewCtx = previewCanvas.getContext('2d');
            
            startCamera();
        }
        
        // Start camera
        async function startCamera() {
            try {
                if (stream) {
                    stream.getTracks().forEach(t => t.stop());
                }
                
                stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: currentFacingMode,
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                });
                
                video.srcObject = stream;
                
                video.onloadedmetadata = () => {
                    video.play();
                    overlayCanvas.width = video.videoWidth;
                    overlayCanvas.height = video.videoHeight;
                    captureCanvas.width = video.videoWidth;
                    captureCanvas.height = video.videoHeight;
                    processCanvas.width = video.videoWidth;
                    processCanvas.height = video.videoHeight;
                    
                    loadingOverlay.classList.add('hidden');
                    startDetection();
                };
            } catch (err) {
                console.error('Camera error:', err);
                loadingOverlay.querySelector('.loading-text').textContent = 'Camera Error';
                loadingOverlay.querySelector('.loading-subtext').textContent = 'Please allow camera access';
            }
        }
        
        // Robust document detection using multiple methods
        function detectDocument(canvas) {
            const src = cv.imread(canvas);
            let bestContour = null;
            let bestScore = 0;
            
            try {
                // Method 1: Canny edge detection with low thresholds
                const corners1 = detectWithCanny(src, 30, 100);
                if (corners1) {
                    const score = scoreContour(corners1, canvas.width, canvas.height);
                    if (score > bestScore) {
                        bestScore = score;
                        bestContour = corners1;
                    }
                }
                
                // Method 2: Canny with medium thresholds
                const corners2 = detectWithCanny(src, 50, 150);
                if (corners2) {
                    const score = scoreContour(corners2, canvas.width, canvas.height);
                    if (score > bestScore) {
                        bestScore = score;
                        bestContour = corners2;
                    }
                }
                
                // Method 3: Adaptive threshold
                const corners3 = detectWithAdaptiveThreshold(src);
                if (corners3) {
                    const score = scoreContour(corners3, canvas.width, canvas.height);
                    if (score > bestScore) {
                        bestScore = score;
                        bestContour = corners3;
                    }
                }
                
                // Method 4: OTSU threshold
                const corners4 = detectWithOtsu(src);
                if (corners4) {
                    const score = scoreContour(corners4, canvas.width, canvas.height);
                    if (score > bestScore) {
                        bestScore = score;
                        bestContour = corners4;
                    }
                }
                
            } catch (err) {
                console.debug('Detection error:', err);
            } finally {
                src.delete();
            }
            
            return bestContour;
        }
        
        // Canny edge detection method
        function detectWithCanny(src, thresh1, thresh2) {
            const gray = new cv.Mat();
            const blur = new cv.Mat();
            const edges = new cv.Mat();
            const contours = new cv.MatVector();
            const hierarchy = new cv.Mat();
            
            try {
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 0);
                cv.Canny(blur, edges, thresh1, thresh2);
                
                // Dilate to connect broken edges
                const kernel = cv.Mat.ones(3, 3, cv.CV_8U);
                cv.dilate(edges, edges, kernel);
                kernel.delete();
                
                cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                
                const corners = findLargestQuad(contours, src.cols, src.rows);
                return corners;
                
            } finally {
                gray.delete();
                blur.delete();
                edges.delete();
                contours.delete();
                hierarchy.delete();
            }
        }
        
        // Adaptive threshold method
        function detectWithAdaptiveThreshold(src) {
            const gray = new cv.Mat();
            const blur = new cv.Mat();
            const thresh = new cv.Mat();
            const contours = new cv.MatVector();
            const hierarchy = new cv.Mat();
            
            try {
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 0);
                cv.adaptiveThreshold(blur, thresh, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 11, 2);
                
                cv.findContours(thresh, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                
                return findLargestQuad(contours, src.cols, src.rows);
                
            } finally {
                gray.delete();
                blur.delete();
                thresh.delete();
                contours.delete();
                hierarchy.delete();
            }
        }
        
        // OTSU threshold method
        function detectWithOtsu(src) {
            const gray = new cv.Mat();
            const blur = new cv.Mat();
            const thresh = new cv.Mat();
            const contours = new cv.MatVector();
            const hierarchy = new cv.Mat();
            
            try {
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 0);
                cv.threshold(blur, thresh, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);
                
                cv.findContours(thresh, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
                
                return findLargestQuad(contours, src.cols, src.rows);
                
            } finally {
                gray.delete();
                blur.delete();
                thresh.delete();
                contours.delete();
                hierarchy.delete();
            }
        }
        
        // Find the largest quadrilateral contour
        function findLargestQuad(contours, width, height) {
            let maxArea = 0;
            let bestCorners = null;
            const minArea = (width * height) * 0.05; // At least 5% of frame
            const maxAreaLimit = (width * height) * 0.95; // At most 95% of frame
            
            for (let i = 0; i < contours.size(); i++) {
                const contour = contours.get(i);
                const area = cv.contourArea(contour);
                
                if (area < minArea || area > maxAreaLimit) continue;
                
                const peri = cv.arcLength(contour, true);
                const approx = new cv.Mat();
                cv.approxPolyDP(contour, approx, 0.02 * peri, true);
                
                // Looking for quadrilateral
                if (approx.rows === 4) {
                    if (area > maxArea && isValidQuad(approx, width, height)) {
                        maxArea = area;
                        bestCorners = [];
                        for (let j = 0; j < 4; j++) {
                            bestCorners.push({
                                x: approx.data32S[j * 2],
                                y: approx.data32S[j * 2 + 1]
                            });
                        }
                    }
                }
                approx.delete();
            }
            
            if (bestCorners) {
                bestCorners = orderCorners(bestCorners);
            }
            
            return bestCorners;
        }
        
        // Check if quad is valid (reasonable aspect ratio, not too skewed)
        function isValidQuad(approx, width, height) {
            const corners = [];
            for (let i = 0; i < 4; i++) {
                corners.push({
                    x: approx.data32S[i * 2],
                    y: approx.data32S[i * 2 + 1]
                });
            }
            
            // Check all corners are within frame
            for (const c of corners) {
                if (c.x < 0 || c.x > width || c.y < 0 || c.y > height) {
                    return false;
                }
            }
            
            // Check angles are reasonable (not too acute or obtuse)
            const ordered = orderCorners(corners);
            for (let i = 0; i < 4; i++) {
                const p1 = ordered[i];
                const p2 = ordered[(i + 1) % 4];
                const p3 = ordered[(i + 2) % 4];
                
                const angle = getAngle(p1, p2, p3);
                if (angle < 45 || angle > 135) return false;
            }
            
            return true;
        }
        
        // Calculate angle at p2
        function getAngle(p1, p2, p3) {
            const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
            const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };
            const dot = v1.x * v2.x + v1.y * v2.y;
            const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
            const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
            const angle = Math.acos(dot / (mag1 * mag2)) * (180 / Math.PI);
            return angle;
        }
        
        // Order corners: top-left, top-right, bottom-right, bottom-left
        function orderCorners(corners) {
            const sorted = [...corners].sort((a, b) => a.y - b.y);
            const top = sorted.slice(0, 2).sort((a, b) => a.x - b.x);
            const bottom = sorted.slice(2, 4).sort((a, b) => a.x - b.x);
            return [top[0], top[1], bottom[1], bottom[0]];
        }
        
        // Score a contour (bigger and more centered = better)
        function scoreContour(corners, width, height) {
            if (!corners || corners.length !== 4) return 0;
            
            // Calculate area
            const area = polygonArea(corners);
            const frameArea = width * height;
            const areaRatio = area / frameArea;
            
            // Prefer 20-80% of frame
            let areaScore = 0;
            if (areaRatio >= 0.1 && areaRatio <= 0.9) {
                areaScore = areaRatio * 100;
            }
            
            // Calculate how centered the contour is
            const centerX = corners.reduce((sum, c) => sum + c.x, 0) / 4;
            const centerY = corners.reduce((sum, c) => sum + c.y, 0) / 4;
            const distFromCenter = Math.sqrt(
                Math.pow(centerX - width/2, 2) + 
                Math.pow(centerY - height/2, 2)
            );
            const maxDist = Math.sqrt(Math.pow(width/2, 2) + Math.pow(height/2, 2));
            const centerScore = (1 - distFromCenter / maxDist) * 50;
            
            return areaScore + centerScore;
        }
        
        // Calculate polygon area using shoelace formula
        function polygonArea(corners) {
            let area = 0;
            const n = corners.length;
            for (let i = 0; i < n; i++) {
                const j = (i + 1) % n;
                area += corners[i].x * corners[j].y;
                area -= corners[j].x * corners[i].y;
            }
            return Math.abs(area / 2);
        }
        
        // Detection loop
        function startDetection() {
            statusDot.classList.add('searching');
            statusText.textContent = 'Looking for document...';
            
            detectionLoop = setInterval(() => {
                if (!video || video.paused) return;
                
                captureCtx.drawImage(video, 0, 0);
                overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                
                const corners = detectDocument(captureCanvas);
                
                if (corners && corners.length === 4) {
                    consecutiveDetections++;
                    
                    if (consecutiveDetections >= DETECTION_THRESHOLD) {
                        isDocumentDetected = true;
                        detectedCorners = corners;
                        
                        // Draw detection overlay
                        drawDetectionOverlay(corners);
                        
                        statusDot.classList.remove('searching');
                        statusDot.classList.add('detected');
                        statusText.textContent = 'Document detected!';
                        guideFrame.classList.add('detected');
                        captureBtn.classList.add('detected');
                    }
                } else {
                    consecutiveDetections = 0;
                    isDocumentDetected = false;
                    detectedCorners = null;
                    
                    statusDot.classList.remove('detected');
                    statusDot.classList.add('searching');
                    statusText.textContent = 'Looking for document...';
                    guideFrame.classList.remove('detected');
                    captureBtn.classList.remove('detected');
                }
                
            }, 150); // ~7fps for detection
        }
        
        // Draw the detected document outline
        function drawDetectionOverlay(corners) {
            const scaleX = overlayCanvas.width / captureCanvas.width;
            const scaleY = overlayCanvas.height / captureCanvas.height;
            
            overlayCtx.beginPath();
            overlayCtx.moveTo(corners[0].x * scaleX, corners[0].y * scaleY);
            for (let i = 1; i < 4; i++) {
                overlayCtx.lineTo(corners[i].x * scaleX, corners[i].y * scaleY);
            }
            overlayCtx.closePath();
            
            // Fill
            overlayCtx.fillStyle = 'rgba(0, 255, 100, 0.15)';
            overlayCtx.fill();
            
            // Stroke
            overlayCtx.strokeStyle = '#00ff66';
            overlayCtx.lineWidth = 3;
            overlayCtx.stroke();
            
            // Corners
            overlayCtx.fillStyle = '#00ff66';
            corners.forEach(corner => {
                overlayCtx.beginPath();
                overlayCtx.arc(corner.x * scaleX, corner.y * scaleY, 8, 0, Math.PI * 2);
                overlayCtx.fill();
            });
        }
        
        // Stop detection
        function stopDetection() {
            if (detectionLoop) {
                clearInterval(detectionLoop);
                detectionLoop = null;
            }
        }
        
        // Capture and process image
        function captureImage() {
            captureCtx.drawImage(video, 0, 0);
            
            let outputCanvas;
            
            if (isDocumentDetected && detectedCorners) {
                // Apply perspective correction
                outputCanvas = applyPerspectiveCorrection(captureCanvas, detectedCorners);
            } else {
                // Just use the full frame
                outputCanvas = document.createElement('canvas');
                outputCanvas.width = captureCanvas.width;
                outputCanvas.height = captureCanvas.height;
                outputCanvas.getContext('2d').drawImage(captureCanvas, 0, 0);
            }
            
            // Resize for output
            const maxSize = 1200;
            const scale = Math.min(maxSize / outputCanvas.width, maxSize / outputCanvas.height, 1);
            
            previewCanvas.width = outputCanvas.width * scale;
            previewCanvas.height = outputCanvas.height * scale;
            previewCtx.drawImage(outputCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
            
            // Enhance the image
            enhanceImage(previewCanvas);
            
            // Store
            capturedImageData = previewCanvas.toDataURL('image/jpeg', 0.85);
            
            // Show preview
            stopDetection();
            cameraSection.classList.add('hidden');
            previewSection.classList.add('active');
        }
        
        // Apply perspective transformation
        function applyPerspectiveCorrection(canvas, corners) {
            const src = cv.imread(canvas);
            
            // Calculate output dimensions
            const widthTop = Math.sqrt(Math.pow(corners[1].x - corners[0].x, 2) + Math.pow(corners[1].y - corners[0].y, 2));
            const widthBottom = Math.sqrt(Math.pow(corners[2].x - corners[3].x, 2) + Math.pow(corners[2].y - corners[3].y, 2));
            const width = Math.max(widthTop, widthBottom);
            
            const heightLeft = Math.sqrt(Math.pow(corners[3].x - corners[0].x, 2) + Math.pow(corners[3].y - corners[0].y, 2));
            const heightRight = Math.sqrt(Math.pow(corners[2].x - corners[1].x, 2) + Math.pow(corners[2].y - corners[1].y, 2));
            const height = Math.max(heightLeft, heightRight);
            
            // Source points
            const srcPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
                corners[0].x, corners[0].y,
                corners[1].x, corners[1].y,
                corners[2].x, corners[2].y,
                corners[3].x, corners[3].y
            ]);
            
            // Destination points
            const dstPts = cv.matFromArray(4, 1, cv.CV_32FC2, [
                0, 0,
                width, 0,
                width, height,
                0, height
            ]);
            
            const M = cv.getPerspectiveTransform(srcPts, dstPts);
            const dst = new cv.Mat();
            cv.warpPerspective(src, dst, M, new cv.Size(width, height));
            
            // Convert to canvas
            const outputCanvas = document.createElement('canvas');
            outputCanvas.width = width;
            outputCanvas.height = height;
            cv.imshow(outputCanvas, dst);
            
            // Cleanup
            src.delete();
            srcPts.delete();
            dstPts.delete();
            M.delete();
            dst.delete();
            
            return outputCanvas;
        }
        
        // Simple image enhancement
        function enhanceImage(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Increase contrast slightly
            const factor = 1.1;
            const intercept = 128 * (1 - factor);
            
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, Math.max(0, data[i] * factor + intercept));
                data[i + 1] = Math.min(255, Math.max(0, data[i + 1] * factor + intercept));
                data[i + 2] = Math.min(255, Math.max(0, data[i + 2] * factor + intercept));
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        // Retake
        function retake() {
            capturedImageData = null;
            consecutiveDetections = 0;
            previewSection.classList.remove('active');
            cameraSection.classList.remove('hidden');
            startDetection();
        }
        
        // Use image
        function useImage() {
            // In JotForm, this would send to the form
            alert('Image captured!\n\nSize: ' + Math.round(capturedImageData.length / 1024) + ' KB\n\nIn JotForm this would be submitted with your form.');
            console.log('Image data:', capturedImageData.substring(0, 100) + '...');
        }
        
        // Switch camera
        function switchCamera() {
            currentFacingMode = currentFacingMode === 'environment' ? 'user' : 'environment';
            stopDetection();
            startCamera();
        }
        
        // Event listeners
        document.getElementById('captureBtn').addEventListener('click', captureImage);
        document.getElementById('retakeBtn').addEventListener('click', retake);
        document.getElementById('useImageBtn').addEventListener('click', useImage);
        document.getElementById('switchCameraBtn').addEventListener('click', switchCamera);
        document.getElementById('flashBtn').addEventListener('click', () => {
            alert('Flash not supported in web browsers');
        });
        
        // Check for OpenCV
        function checkOpenCV() {
            if (typeof cv !== 'undefined' && cv.Mat) {
                window.opencvReady = true;
                initScanner();
            } else {
                setTimeout(checkOpenCV, 100);
            }
        }
        
        checkOpenCV();
    </script>
</body>
</html>
